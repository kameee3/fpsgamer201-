<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>3D Dodge — Web Embed Game</title>
  <style>
    html,body{height:100%;margin:0;background:#0b0f1a;overflow:hidden;font-family:system-ui, -apple-system, "Segoe UI", Roboto, "Hiragino Kaku Gothic ProN", "Meiryo", sans-serif}
    #game{width:100%;height:100%;display:block}
    #ui{position:absolute;left:12px;top:12px;color:#e6eef8;z-index:2;pointer-events:none}
    #hud{background:rgba(0,0,0,0.25);backdrop-filter:blur(4px);padding:8px 12px;border-radius:10px}
    #startBtn,#restartBtn{pointer-events:auto;margin-top:8px;padding:8px 12px;border:none;border-radius:8px;background:#4b7cff;color:white;cursor:pointer}
    #tip{font-size:13px;opacity:0.9;margin-top:6px}
    #overlay{position:absolute;inset:0;display:flex;align-items:center;justify-content:center;z-index:3}
    #panel{background:linear-gradient(180deg, rgba(255,255,255,0.04), rgba(255,255,255,0.02));padding:18px;border-radius:12px;color:#eaf2ff;text-align:center;max-width:360px}
    a{color:#bcd0ff}
  </style>
</head>
<body>
  <canvas id="game"></canvas>
  <div id="ui">
    <div id="hud">
      <div>Score: <span id="score">0</span></div>
      <div id="tip">Controls: A / D or ← / → — Move. Space to boost.</div>
      <button id="startBtn">Start Game</button>
      <button id="restartBtn" style="display:none">Restart</button>
    </div>
  </div>
  <div id="overlay">
    <div id="panel">
      <h2>3D Dodge</h2>
      <p>障害物を避けてハイスコアを目指そう！</p>
      <p style="font-size:13px;opacity:0.9">矢印キーかA/Dで左右移動、スペースで一瞬ブースト</p>
      <button id="overlayStart">Play</button>
      <p style="font-size:12px;margin-top:10px;opacity:0.8">このファイルを保存してそのままWebに埋め込めます (iframe推奨)</p>
    </div>
  </div>

<script src="https://unpkg.com/three@0.152.2/build/three.min.js"></script>
<script>
// Simple 3D dodge game using Three.js
(() => {
  const canvas = document.getElementById('game');
  const scoreEl = document.getElementById('score');
  const startBtn = document.getElementById('startBtn');
  const restartBtn = document.getElementById('restartBtn');
  const overlay = document.getElementById('overlay');
  const overlayStart = document.getElementById('overlayStart');

  let scene, camera, renderer, player, light;
  let obstacles = [];
  let lastTime = 0;
  let speed = 12; // forward speed
  let laneX = 0; // player x
  let moveTarget = 0;
  let score = 0;
  let running = false;
  let spawnTimer = 0;
  let boost = false;

  function init(){
    scene = new THREE.Scene();
    camera = new THREE.PerspectiveCamera(60, innerWidth/innerHeight, 0.1, 200);
    camera.position.set(0, 6, 12);
    camera.lookAt(0,0,0);

    renderer = new THREE.WebGLRenderer({canvas, antialias:true});
    renderer.setSize(innerWidth, innerHeight);
    renderer.setPixelRatio(Math.min(2, window.devicePixelRatio || 1));

    // ground
    const gmat = new THREE.MeshStandardMaterial({color:0x11121a});
    const ground = new THREE.Mesh(new THREE.PlaneGeometry(40,400), gmat);
    ground.rotation.x = -Math.PI/2;
    ground.position.y = -1.5;
    scene.add(ground);

    // player
    const pmat = new THREE.MeshStandardMaterial({color:0x7df0ff, roughness:0.4, metalness:0.1});
    player = new THREE.Mesh(new THREE.SphereGeometry(0.8,24,24), pmat);
    player.position.set(0,0,0);
    scene.add(player);

    // track walls
    const wallMat = new THREE.MeshStandardMaterial({color:0x0f1724, roughness:0.9});
    const left = new THREE.Mesh(new THREE.BoxGeometry(1,6,400), wallMat);
    left.position.set(-6.5,1,0); scene.add(left);
    const right = new THREE.Mesh(new THREE.BoxGeometry(1,6,400), wallMat);
    right.position.set(6.5,1,0); scene.add(right);

    // lights
    light = new THREE.DirectionalLight(0xffffff, 1.1);
    light.position.set(5,10,5);
    scene.add(light);
    scene.add(new THREE.AmbientLight(0x404556, 0.9));

    window.addEventListener('resize', onResize);
    document.addEventListener('keydown', onKey);
    document.addEventListener('keyup', onKeyUp);
  }

  function onResize(){
    camera.aspect = innerWidth/innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(innerWidth, innerHeight);
  }

  function onKey(e){
    if(!running) return;
    if(e.code === 'ArrowLeft' || e.key === 'a' || e.key === 'A') moveTarget = -4;
    if(e.code === 'ArrowRight' || e.key === 'd' || e.key === 'D') moveTarget = 4;
    if(e.code === 'Space') boost = true;
  }
  function onKeyUp(e){
    if(!running) return;
    if(e.code === 'ArrowLeft' || e.key === 'a' || e.key === 'A') moveTarget = 0;
    if(e.code === 'ArrowRight' || e.key === 'd' || e.key === 'D') moveTarget = 0;
    if(e.code === 'Space') boost = false;
  }

  function startGame(){
    // reset
    obstacles.forEach(o=>scene.remove(o.mesh)); obstacles = [];
    score = 0; scoreEl.textContent = '0';
    speed = 12; spawnTimer = 0; running = true; overlay.style.display='none'; startBtn.style.display='none'; restartBtn.style.display='none';
    lastTime = performance.now();
    requestAnimationFrame(loop);
  }

  function endGame(){
    running = false; overlay.style.display='flex'; overlay.querySelector('h2').textContent = 'Game Over';
    overlay.querySelector('p').textContent = `スコア: ${score}`;
    restartBtn.style.display = 'inline-block';
    startBtn.style.display = 'none';
  }

  function spawnObstacle(){
    const z = -120; // far
    const x = (Math.round(Math.random()*2)-1)*4; // -4,0,4
    const size = 0.8 + Math.random()*1.6;
    const geom = new THREE.BoxGeometry(size, size* (0.6+Math.random()*1.6), size);
    const mat = new THREE.MeshStandardMaterial({color:0xff7a7a, roughness:0.7});
    const mesh = new THREE.Mesh(geom, mat);
    mesh.position.set(x, 0, z);
    scene.add(mesh);
    obstacles.push({mesh, passed:false});
  }

  function loop(t){
    const dt = Math.min(0.05, (t - lastTime)/1000);
    lastTime = t;
    if(!running) return;

    // player lateral movement smoothing
    laneX += (moveTarget - laneX) * Math.min(1, 8*dt);
    player.position.x = laneX;

    // forward movement: move obstacles toward camera
    const forward = (speed + (boost?10:0)) * dt;
    for(let i = obstacles.length-1;i>=0;i--){
      const o = obstacles[i];
      o.mesh.position.z += forward * 10; // scale to feel right
      if(!o.passed && o.mesh.position.z > 2){ o.passed = true; score += 1; scoreEl.textContent = score; }
      if(o.mesh.position.z > 30){ scene.remove(o.mesh); obstacles.splice(i,1); }
      // collision simple
      const dx = o.mesh.position.x - player.position.x;
      const dz = o.mesh.position.z - player.position.z;
      const dist = Math.sqrt(dx*dx + dz*dz);
      if(dist < 1.6 + o.mesh.geometry.parameters.width/2){ endGame(); }
    }

    // spawn
    spawnTimer += dt;
    if(spawnTimer > Math.max(0.25, 1.4 - score*0.02)){
      spawnTimer = 0; spawnObstacle();
      // gradually increase speed
      speed += 0.12;
    }

    // camera subtle follow
    camera.position.x += (laneX - camera.position.x) * 0.06;

    renderer.render(scene, camera);
    requestAnimationFrame(loop);
  }

  // UI wiring
  startBtn.onclick = startGame;
  overlayStart.onclick = startGame;
  restartBtn.onclick = ()=>{ overlay.style.display='none'; startGame(); };

  // create
  init();

  // mobile tilt/touch basic support
  let touchStartX = null;
  window.addEventListener('touchstart', e=>{ if(e.touches && e.touches[0]) touchStartX = e.touches[0].clientX; });
  window.addEventListener('touchmove', e=>{ if(!running) return; if(e.touches && e.touches[0] && touchStartX!==null){ const dx = e.touches[0].clientX - touchStartX; moveTarget = Math.max(-4, Math.min(4, dx/ (innerWidth/4))); } });
  window.addEventListener('touchend', ()=>{ touchStartX = null; moveTarget = 0; });

  // show initial tip
  overlay.style.display = 'flex';
})();
</script>
</body>
</html>
